**Collections** — это набор классов и интерфейсов, предназначенных для хранения и управления группами объектов в Java. Это структуры данных, которые позволяют эффективно организовывать, добавлять, удалять и обрабатывать данные в структурированном формате.

## Иерархия классов и интерфейсов в Collections

![](https://api.faang-school.com/api/storage/file/egb3798n.png)

На изображении предоставлены основные и наиболее важные классы и интерфейсы коллекций. Рассмотрим их поближе:

`Iterable` — интерфейс, который указывает на то, что объект, который его реализует, можно “обойти”, т.е. проитерироваться по всем его элементам. Содержит метод, который возвращает объект для обхода элементов: `Iterator<T> iterator()`.

`Iterator` — это класс, с помощью которого в некотором порядке можно обойти коллекцию элементов. Содержит простые методы:

1. `boolean hasNext()` — сообщает, есть ли ещё элементы
    
2. `E next()` — возвращает следующий элемент для обхода
    

`Collection` — главный интерфейс Java Collection Framework. От него наследуются все остальные интерфейсы коллекций, и он содержит основные методы, которые должны поддерживаться каждой коллекцией. Рассмотрим некоторые из них:

1. `int size()` — размер коллекции, т.е. сколько в ней элементов
    
2. `boolean isEmpty()` — метод для проверки, пуста ли коллекция
    
3. `boolean contains(Object o)` — проверка на содержание конкретного элемента в коллекции
    
4. `Object[] toArray()` — возвращает массив из элементов коллекции
    
5. `boolean add(E e)` — добавляет элемент в коллекцию
    
6. `boolean remove(Object o)` — удаляет элемент из коллекции
    
7. `boolean containsAll(Collection<?> c)` — проверка на содержание всех переданных элементов в коллекции
    
8. `boolean addAll(Collection<? extends E> c)` — добавляет все переданные элементы в коллекцию. Возвращает `true`, если коллекция была изменена в результате операции
    
9. `boolean removeAll(Collection<?> c)` - удаляет все переданные элементы из коллекции. Возвращает `true`, если коллекция была изменена в результате операции. Если переданных элементов в коллекции не было, то ничего не произойдет — они будут проигнорированы.
    
10. `void clear()` - полностью очищает коллекцию
    

`List` — упорядоченная коллекция без ограничений на сами элементы. Наиболее популярные реализации: `ArrayList`, `LinkedList`. О конкретных коллекциях поговорим в следующих уроках.

`Set` — неупорядоченная коллекция, которая не допускает дублирования элементов. Наиболее популярные реализации: `HashSet`, `TreeSet`, `LinkedHashSet`.

`Queue` — коллекция, основанная на принципе FIFO (первый вошел, первый вышел), работает по принципу обычной очереди, как в любом заведении: тот, кто первый пришёл, первый выйдет (будет обслужен). Наиболее популярные реализации: `LinkedList`, `PriorityQueue`.

Отдельно стоит `Map` — можете увидеть это на схеме. Действительно, внутренней устройство `Map` отличается от остальных коллекций, и об этом тоже мы подробнее поговорим уже совсем скоро.

`Map` — коллекция, представляющая собой список пар ключ-значение, где все ключи должны быть уникальными. Не наследуется от `Collection`, потому что хранит именно пары значений, а не одиночные элементы. Несмотря на это, является частью Java Collection Framework. Наиболее популярные реализации: `HashMap`, `TreeMap`, `LinkedHashMap`.

## Сортировка коллекций

Сортировка коллекций является важной операцией во многих приложениях. В Java для сортировки коллекций используются интерфейсы `Comparable` и `Comparator`.

`Comparable` определяет метод `int compareTo(T o)`, который позволяет сравнивать объекты и устанавливать их порядок сортировки. Классы, реализующие интерфейс `Comparable`, могут быть сравнимыми и использоваться для сортировки коллекций. Контракт такой:

1. Если вернулось отрицательное число, значит текущий (`this`) объект меньше переданного;
    
2. Если вернулся 0, значит объекты равны;
    
3. Если вернулось положительное число, значит текущий (`this`) элемент больше переданного.
    

```
public class Wisard implements Comparable<Wisard> {
    private String name;
    private int age;
    
    // Конструкторы, геттеры, сеттеры
    
		// Реализовано сравнение волшебников по их возрасту
    @Override
    public int compareTo(Wisard other) {
        return this.age - other.age;
    }
}
```

`Comparator` позволяет определить пользовательский порядок сортировки для объектов, не модифицируя их. Он определяет метод `int compare(T o1, T o2)`, который принимает два объекта и возвращает отрицательное число, ноль или положительное число в зависимости от их относительного порядка.

По сути работает так же, как и `Comparable`, но `Comparable` реализуется в рамках класса, и может иметь только одну реализацию, тогда как `Comparator` является независимым и самодостаточным, при этом без ограничений на количество разных реализаций.

```
public class WisardNameComparator implements Comparator<Wisard> {
    // Реализовано сравнение по именам волшебников в алфавитном порядке
    @Override
    public int compare(Wisard wisard1, Wisard wisard2) {
        return wisard1.getName().compareTo(wisard2.getName());
    }
}
```

Можно также создать `WisardAgeComparator` и любые другие классы для сравнения.

## Обобщения

Стоит обратить внимание на то, что коллекции обобщённые, т.е. могут содержать элементы любого типа. Обобщения (generics) позволяют добавить гибкости в написании кода и указывать типы элементов в коллекциях во время компиляции, что обеспечивает безопасность типов и упрощает код. Обобщенные коллекции можно использовать для хранения и обработки объектов разных типов, которые нужны пользователю.

## Преимущества коллекций

1. **Удобство**: коллекции предоставляют удобные методы для добавления, удаления, поиска и обработки элементов без необходимости вручную управлять массивами или другими низкоуровневыми структурами данных.
    
2. **Гибкость**: коллекции могут быть динамическими, то есть они автоматически расширяются или сжимаются при добавлении или удалении элементов (в отличие от массивов).
    
3. **Расширяемость**: **Java Collections Framework** предоставляет широкий набор классов и интерфейсов, которые позволяют разработчиками создавать свои реализации коллекций.
    
4. **Универсальность**: коллекции могут хранить любой тип объектов, включая примитивы и пользовательские классы.
    
5. **Производительность**: классы и интерфейсы реализованы опытными разработчиками с использованием оптимальных алгоритмов и структур данных, что позволяет достичь высокой эффективности при обработке данных.
    
6. **Поддержка готовых алгоритмов**: предоставляются ряд готовых алгоритмов для сортировки, поиска и обработки элементов в коллекциях, что упрощает разработку.


![[Pasted image 20250928122932.png]]