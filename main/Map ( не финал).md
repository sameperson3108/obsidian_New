`Map` — это структура данных ключ-значение, также известная как ассоциативный массив, словарь или хеш-таблица, представляет собой коллекцию пар ключ-значение, где каждому уникальному ключу соответствует определенное значение. Такая структура данных обеспечивает быстрый доступ к данным, вставку и удаление элементов на основе ключей. Эта структура данных широко используется во множестве задач, таких как кэширование, хранение настроек, сопоставление имен пользователей с их данными и многое другое

В Java структура данных “ключ-значение” представлена интерфейсом Map и его реализациями: `HashMap`, `LinkedHashMap` и `TreeMap`. Рассмотрим их подробнее.

`HashMap` — основана на хэш-таблице, обеспечивает очень быстрый доступ к элементам по ключам. Не гарантирует порядок элементов и позволяет хранить `null`-значения, но `null`-ключ может быть только единственный, потому что все ключи должны быть уникальны

Представьте, что `HashMap` —это огромный шкаф с ящиками, а каждый ящик имеет уникальный номер, который мы знаем как хэш-код. В этих ящиках мы храним разные предметы (ключи и значения). Чтобы найти нужный предмет, нам нужно знать номер ящика, а чтобы положить предмет в ящик, мы должны определить его номер.

Когда мы хотим добавить новый предмет в `HashMap`, мы сначала определяем его ключ. Для каждого ключа существует хэш-функция, которая превращает ключ в хэш-код. Хэш-код является номером ящика, в котором будет храниться предмет (пара ключ-значение). Процесс представления всех ключей в виде их хэш-кодов называется хэшированием.

Однако иногда у нас возникает ситуация, когда два разных ключа имеют один и тот же хэш-код (номер ящика). Это называется коллизией. Это возможно просто потому, что метод `hashCode` в Java возвращает тип данных `int`, который имеет ограниченный диапазон возможных значений. Т.е. если создать достаточно много объектов одного класса, то у хотя бы двух из них однажды совпадет хэш-код, просто потому, что таких объектов будут миллиарды!

Чтобы разрешить коллизии, в каждом ящике на самом деле хранится связный список пар ключ-значение, а не одна пара. Когда происходит коллизия, мы просто добавляем новую пару ключ-значение в этот список.

Когда мы хотим найти значение по ключу, мы используем хэш-функцию ключа (метод `hashCode`) для определения номера ящика. Затем мы проверяем список в ящике и ищем нужный ключ (сравниваем через `equals`). Если ключ найден, мы возвращаем соответствующее значение.

Удаление пары ключ-значение также происходит с использованием хэш-функции и номера ящика. Мы находим нужный ящик, проверяем список и удаляем пару с нужным ключом.

Давайте разберем основные компоненты и принципы работы `HashMap`:

- **Entry**. Это объект, который как раз хранит в себе пару (ключ и значение). Просто обычный Java объект, в котором хранятся и ключ, и значение. Ничего сложного в нем нет.
    
- **Массив (бакеты)**. В основе `HashMap` лежит массив `Entry`, где каждый элемент массива называется бакетом. Бакеты хранят ссылки на узлы связанных списков, которые содержат пары ключ-значение. В нашем примере бакет - это тот самый ящик в шкафу.
    
- **Узлы связанного списка**. Узлы связанного списка представляют собой объекты, содержащие ключ, значение и ссылку на следующий узел. В случае коллизий (когда два разных ключа имеют одинаковый хэш-код), эти объекты образуют цепочку. Т.е. здесь уже несколько пар ключ-значение могут лежать в одном бакете (ящике).
    
- **Хэш-функция**. Секретная формула хэш-мапы. Благодаря методу `hashcode()` ключ преобразовывается в хэш-код, который представляет собой интовое число. Затем на основе хэш-кода мапа вычисляет индекс в нашем массиве `Entry[]`, куда будет помещена пара ключ-значение (`Entry`).
    
- **Разрешение коллизий**. В случае коллизии (когда два ключа имеют одинаковый хеш-код), новая пара ключ-значение будет добавлена в связанный список того же бакета. При поиске, вставке или удалении элемента, HashMap будет искать элемент в связанном списке соответствующего бакета.
    
- **Изменение размера (ресайзинг)**. При достижении определенного порога заполнения (коэффициент заполнения, по умолчанию равный 0.75), происходит изменение размера массива и перераспределение элементов по бакетам. Это делается для поддержания эффективной работы `HashMap` и уменьшения вероятности возникновения длинных цепочек связанных списков.
    
- **Итерация**. Для итерации по ключам, значениям или парам ключ-значение, HashMap предоставляет набор ключей (`keySet()`), коллекцию значений (`values()`) и набор пар `entrySet()`.
    

## Запись

Создадим `HashMap` для хранения возраста людей (ключ - имя, значение - возраст).

```
Map<String, Integer> map = new HashMap<>();
```

![](https://api.faang-school.com/api/storage/file/9gz2amgp.png)

Когда мы создаем пустую мапу, то на самом деле внутри нее уже лежит массив `Entry[]`, но только в каждой его ячейке находится `null` - т.е. он полностью пуст, т.к. мы еще не добавили туда ни одной пары ключ-значение.

Чтобы добавить новую пару в хэш-мапу, используем метод `put()`:

```
map.put("Alice", 28);
```

![](https://api.faang-school.com/api/storage/file/b86x3w8p.png)

В этот момент в хэш-мапе происходит следующее:

1. У объекта ключа, переданного в `put()`, вызывается метод `hashCode()`.
    
2. К полученному хэшу применяется секретная формула `HashMap`, которая вычисляет из него индекс в массиве `Entry[]`, в который нужно положить этот ключ.
    
3. Переданная пара ключ-значение сохраняется в полученную ячейку массива `Entry[]` внутри `HashMap`.
    

## Чтение

Чтобы получить значение по ключу используем метод `get()`, в аргументы которого передадим имя нужного нам человека. Например, мы хотим узнать сколько лет Алисе:

```
Integer ageOfAlice = map.get("Alice");
```

![](https://api.faang-school.com/api/storage/file/wgpmy78b.png)

![](https://api.faang-school.com/api/storage/file/mg7zy78e.png)

![](https://api.faang-school.com/api/storage/file/3gvw0y80.png)

В этот момент в хэш-мапе происходит следующее:

1. У объекта ключа, переданного в `get()`, вызывается метод `hashCode()`.
    
2. К полученному хэшу применяется секретная формула HashMap, которая вычисляет из него индекс в массиве `Entry[]`, где хранится наша пара `Entry`.
    
3. Значение переданное в метод `get()` и ключ, который лежит под полученным индексом в массиве `Entry[]` сравниваются через метод equals, чтобы убедиться, что это действительно один и тот же ключ.
    

## Удаление

Чтобы удалить элемент, используем метод `remove()`, в аргументы которого передадим ключ.

```
map.remove("Alice");
```

![](https://api.faang-school.com/api/storage/file/k8njwj8j.png)

![](https://api.faang-school.com/api/storage/file/28ex62g3.png)

![](https://api.faang-school.com/api/storage/file/xg9p6y8w.png)

![](https://api.faang-school.com/api/storage/file/b8mj00g3.png)

При удалении происходит тоже самое, что и при вызове метода `get()`, только сама пара `Entry` из массива удаляется:

1. У объекта ключа, переданного в `remove()`, вызывается метод `hashCode()`.
    
2. К полученному хэшу применяется секретная формула `HashMap`, которая вычисляет из него индекс в массиве `Entry[]`, где хранится наша пара `Entry`.
    
3. Значение переданное в метод `remove()` и ключ, который лежит под полученным индексом в массиве `Entry[]` сравниваются через метод `equals`, чтобы убедиться, что это действительно один и тот же ключ.
    
4. Когда мы нашли нужный ключ, пара удаляется. Если наш ключ не был найден, то ничего не произойдет, а метод `remove` вернет нам `null`.
    

## Итерация по элементам в мапе

Чтобы пройтись по всем элементам мапы, используем цикл `for` и метод `entrySet()` (создает `Set` наших пар ключ-значение, которые мы и будем перебирать в цикле)

```
for (Map.Entry<String, Integer> entry : map.entrySet()) {
	System.out.println("Имя: " + entry.getKey() + ", Возраст: " +
		entry.getValue());
}

```

Теперь посмотрим, как будет выглядеть код, где мы используем все рассмотренные выше методы:

```
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
		public static void main(String[] args) {
        // Создадим HashMap. Ключом будет имя человека,
				// а значением - его возраст.
        Map<String, Integer> map =new HashMap<>();

        // Добавим элементы (пары ключ-значение).
				// Для этого используем метод put()
        map.put("Alice", 28);
        map.put("Dima", 25);
        map.put("Vasya", 18);

        // Получим значение по ключу
        Integer ageOfAlice = map.get("Alice");
        System.out.println("Возраст Alice: " + ageOfAlice);

        // Чтобы удалить элемент по ключу, используем метод remove()
        map.remove("Alice");

        // Проверка наличия ключа
        System.out.println("Содержит ли HashMap ключ 'Alice': " +
					map.containsKey("Alice"));

        // Итерация по элементам HashMap
        System.out.println("Итерация по элементам HashMap:");
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(
								"Имя: " + entry.getKey() + ", Возраст: " + entry.getValue()
						);
        }
    }
}

```

## Хеш-функция, equals и hashcode

Хэшмапа имеет недостаток — это возможность коллизий (когда два разных ключа имеют один и тот же хэш-код), что приводит к выбору одного и того же индекса бакета (ячейки массива) для хранения этих ключей. Коллизии могут снижать эффективность HashMap, поскольку они приводят к созданию цепочек в связанных списках, которые замедляют операции поиска, вставки и удаления элементов.

Для того, чтобы определить в какой ячейке (бакете) хранить пару ключ-значение, используется специальная функция. Она преобразует входные данные (обычно строку или объект) в целое число, называемое хэш-кодом. Важно, чтобы хэш-функция при одинаковых входных данных она всегда возвращала один и тот же хэш-код.

Представьте хэш-функцию как рецепт кулинарного блюда. Вы берете ингредиенты (входные данные) и следуете рецепту (хэш-функции), чтобы получить готовое блюдо (хэш-код). Если вы будете следовать одному и тому же рецепту с одними и теми же ингредиентами, то каждый раз получите одно и то же блюдо (тот же хэш-код).

В Java для определения хэш-кода объекта используется метод `hashСode()` класса `Object`. В идеале, хеш-коды для разных объектов должны быть равномерно распределены, чтобы снизить вероятность коллизий и повысить производительность `HashMap`. Однако, даже если два разных объекта имеют одинаковый хэш-код, это не означает, что они равны. Из-за возможности коллизиии.

Чтобы сравнить объекты, которые оказались внутри одного бакета (у нас случилась коллизия), будет использоваться метод класса `Object equals()`. Этот метод проверяет равенство двух объектов. Если при добавлении нового элемента в хэш мапу, в ней уже есть пара, ключ которой имеет такой же хэш-код как и тот, который мы добавляем. И если эти ключи равны по методу `equals()`, то они считаются одним и тем же ключом. Тогда значение по этому ключу будет обновлено новым значением.

Для корректной работы `HashMap`, следует соблюдать два важных правила при переопределении методов `equals()` и `hashCode()` для ключевых объектов:

- **Консистентность**. Если два объекта равны согласно методу `equals()`, их хеш-коды также должны быть равны. Это гарантирует, что равные объекты будут храниться в одном бакете, и операции с ними будут работать правильно.
    
- **Неизменность**. Хеш-код объекта, используемого в качестве ключа, не должен меняться на протяжении его жизненного цикла, поскольку это может привести к непредсказуемому поведению `HashMap`.
    

В следующем примере, мы создадим класс `BadKey`, который всегда возвращает один и тот же хеш-код, что приведет к коллизиям в `HashMap`:

```
import java.util.HashMap;
import java.util.Objects;

public class BadKey {
    private String key;

    public BadKey(String key) {
        this.key = key;
    }

    @Override
    public int hashCode() {
		// Всегда возвращает одно и то же значение хеш-кода, 
		// что приводит к коллизиям
        return 1; 
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        BadKey badKey = (BadKey) obj;
        return Objects.equals(key, badKey.key);
    }

    public static void main(String[] args) {
        HashMap<BadKey, String> badKeyMap = new HashMap<>();

        badKeyMap.put(new BadKey("key1"), "value1");
        badKeyMap.put(new BadKey("key2"), "value2");
        badKeyMap.put(new BadKey("key3"), "value3");

        System.out.println("Size of the HashMap: " + badKeyMap.size());
    }
}
```

В этом примере все пары `Entry` будут находится в одном бакете (ячейке) массива. Таким образом, чтобы найти какой-то элемент, нам нужно будет каждый раз последовательно посмотреть все наши `Entry` в этом бакете и сравнивать ключи по методу `equals`, чтобы найти нужный. Хэш-мапа превращается в один длинный связный список объектов.

Еще один пример bad practice. Мы создадим класс `MutableKey`, который содержит изменяемые поля. Использование объектов с изменяемыми полями в качестве ключей в `HashMap` является плохой практикой, поскольку это может привести к непредсказуемому поведению:

```
import java.util.HashMap;
import java.util.Objects;

public class MutableKey {
    private String key;

    public MutableKey(String key) {
        this.key = key;
    }

    public void setKey(String key) {
        this.key = key;
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(key);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        MutableKey mutableKey = (MutableKey) obj;
        return Objects.equals(key, mutableKey.key);
    }

    public static void main(String[] args) {
        HashMap<MutableKey, String> mutableKeyMap = new HashMap<>();

        MutableKey key1 = new MutableKey("key1");
        mutableKeyMap.put(key1, "value1");

        System.out.println("Before changing key: " + 
					mutableKeyMap.get(key1));

        // Изменение ключа после его добавления в HashMap
        key1.setKey("newKey1");

				// Вернет null
        System.out.println("After changing key: " + mutableKeyMap.get(key1)); 
    }
}
```

В этом примере, после изменения значения ключа `key1`, метод `get()` возвращает `null`, так как хеш-код ключа изменился и `HashMap` не может найти правильный бакет для этого ключа. Она ведь каждый раз его пересчитывает при каждом вызове метода `get()`.

Итак, повторим важные правила, касающиеся `equals` и `hashcode`:

- `equals` и `hashcode` BCЕГДА переопределяются вместе. Точка.
    
- ОБЯЗАНЫ переопределяться для любого класса, объекты которого используются в качестве ключей в `HashMap`. Для значений не нужно.
    
- Переопределяются для ключей потому, что оба используются во внутренней работе `HashMap`. Потому и переопределяются всегда вместе - нужны оба.
    
- `hashcode` должен давать максимально возможное распределение значений для объектов. Т.е. никаких постоянных хэш-кодов для объектов. Иначе все объекты будут иметь один и тот жe `hashcode` и попадать в одну и ту же ячейку массива `Entry`.
    
- `equals` должен производить сравнение объектов по всем значимым полям с точки зрения логики работы приложения.
    
- `hashCode` должен работать по ТЕМ ЖЕ полям, по которым производит сравнение `equals`. Ни больше, ни меньше. Иначе `HashMap` будет работать неправильно.
    

`LinkedHashMap` — по сути та же `HashMap`, за тем исключением, что элементы связаны друг с другом в порядке добавления. Так можно сохранить порядок добавления элементов в словарь, чего не гарантирует `HashMap`. Естественно, на это нужно чуть больше памяти.

`TreeMap` — основана на древовидной структуре данных, обеспечивает доступ к элементам по ключам в отсортированном порядке. Не позволяет хранить `null`-ключи, но допускает `null`-значения. В отличие от `HashMap` и `LinkedHashMap` данная реализация словаря не гарантирует столь же быстрый доступ к данным по ключу: `get`/`put`/`remove`/`containsKey` будут работать за O(logN), а не за O(1).