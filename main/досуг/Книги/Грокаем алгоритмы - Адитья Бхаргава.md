# Глава 1 - Бинарный поиск
Алгоритм - набор инструкций для выполнения некоторой задачи
Бинарный поиск - алгоритм; на входе он получает отсортированный список элементов. Если элемент, который мы ищет, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бинарный поиск возвращает null.
С бинарным поиском каждый раз выбирается середина, что отбрасывает половину оставшихся чисел.
Бинарный поиск выполняется за log2n шагов, а простой поиск за n шагов
Логарифм - операция, обратная возведению в степень
Если максимальное количество попыток совпадает с размером списка - линейное время
Специальная нотация О-большое описывает скорость работы алгоритма. 
О-большое не сообщает скорость в секундах, а позволяет сравнить количество операций.
О-большое определяет время в худшем случае.
![[Pasted image 20251116080918.png]]

# Глава 2 - Сортировка выбором
Связанные списки отлично подходят, когда данные должны читаться последовательно
Массивы отлично подходят для чтения элементов в произвольных позициях
Позиция элемента называется индексом. 
Вместо "Значение n находится в позиции 1" - "Значение n имеет индекс 1"
Массивы: чтение O(1), вставка О(n), удаление О(n)
Списки: чтение О(n), вставка О(1), удаление О(1)
В каждом элементе связанного списка выделяется некоторый объем памяти для хранения адреса следующего элемента. Эта часть элемента называется указателем

# Глава 3 - Рекурсия
Каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая
В рекурсивном случае функция вызывает сама себя
В базовом случае - не вызывает, чтобы предотвратить зацикливание
Во внутренней работе компьютера используется стек именуемый стеком вызовов
Когда вызывается функция из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии 
Рекурсивные функции используют стек вызовов
Каждый вызов создаёт собственную переменную
Стек поддерживает 2 операции - занесение и извлечение элементов

# Глава 4 - Разделяй и властвуй
1. Определить простейший случай как базовый
2. Придумать, как свести задачу к базовому случаю
Бинарный поиск также относится к этой стратегии, как рекурсия и быстрая сортировка
## Быстрая сортировка
Пример для сортировки массива
Сначала в массиве выбирается элемент, который называется опорным
После чего проводится поиск меньших и больших элементов, чем опорный - этот процесс называется разделением.
Теперь у нас есть: подмассив элементов меньше опорного, опорный элемент, подмассив элементов больших опорного
Вне зависимости от выбора опорного элемента, можно рекурсивно вызывать быструю сортировку для всех подмассивов
![[Pasted image 20251116113759.png]]

Обычно константа не влияет, но в некоторых случая может иметь значение. Один из таких случаев - быстрая сортировка и сортировка слиянием
Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента.
Среднее время выполнения быстрой сортировки О(n log n)

# Глава 5 - Хеш-таблицы
Хеш-таблица связывает ключи со значениями
Хеш-таблицы отлично подходят для: моделирование отношений между объектами, устранение дубликатов, кэширование/запоминание данных вместо выполнения работы на сервере
Коллизия - назначение одного элемента двум ключам
В идеале хеш-функция должна равномерно распределять ключи по всему хешу
В среднем Хеш-таблицы выполняют любые операции за время О(1).
В худшем случае все операции выполняются за О(n)
Для предотвращения коллизий необходимы: низкий коэффициент заполнения, хорошея хеш-функция
Коэффициент заполнения = количество элем в хеш-таблице / общее кол-во элементов
Хорошая хеш-функция должна обеспечивать равномерное распределение значений в массиве
Хеш-таблица создаётся объединением хеш-функции с массивом
Как только коэффициент заполнения превышает 0,7, пора изменять размер хеш-таблицы

# Глава 6 - Поиск в ширину
С помощью поиска в ширину можно: реализовать проверку правописания, найти ближайшего врача, создать поискового робота

Алгоритм для решения задачи поиска кратчайшего пути называется поиском в ширину
Каждый граф состоит из узлов и ребер
Узел может быть соединен с несколькими другими узлами. Эти узлы называются внутренними или внешними соседями

Поиск в ширину может ответить на 2 вопроса:
1. Существую ли путь от узла А к узлу B?
2. Как выглядит кратчайший путь от узла А к узлу B?

В очереди поддерживаются 2 операции: постановка в очередь и извлечение из очереди

Очередь относится к структура данных FIFO - First In, First Out
А Стек к LIFO - Last In, First Out

Направленный граф - отношения действуют только в одну сторону. В ненаправленном графе стрелок нет

Граф, в котором нет ребер, указывающих в обратном направлении - дерево
![[Pasted image 20251116190113.png]]

# Глава 7 - Деревья
Дерево - связный ациклический граф
Как и графы - деревья состоят из узлов и ребер.
Корневое дерево - дерево, у которого имеется 1 узел, от которого можно перейти к любому другому узлу
У узлом могут быть дочерние узлы, а у дочерних узлов может быть родительский узел
Существует только 1 узел без родителя - корневой
Узлы, не имеющие дочерних узлов, называются листовыми узлами(листьями)
Поиск в ширину является алгоритмом обхода: это значит, что он посещает каждый узел дерева
В деревьях не бывает циклов

Поиск в глубину не может использоваться для нахождения кратчайшего пути

Бинарные деревья - деревья, узлы которого могут иметь не более 2 дочерних узлов. Дочерние узлы традиционно называются левым и правым узлами.

Код Хаффмана - хороший пример использования бинарных деревьев. Он также лежит в основе алгоритмов сжатия текста
В кодировке Хаффмана коды не обязательно должны иметь одинаковую длину.

![[Pasted image 20251116201950.png]]

# Глава 8 - Сбалансированные деревья
