# Глава 1 - Бинарный поиск
Алгоритм - набор инструкций для выполнения некоторой задачи
Бинарный поиск - алгоритм; на входе он получает отсортированный список элементов.

Если элемент, который мы ищет, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бинарный поиск возвращает null.

С бинарным поиском каждый раз выбирается середина, что отбрасывает половину оставшихся чисел.

Бинарный поиск выполняется за log2n шагов, а простой поиск за n шагов
Логарифм - операция, обратная возведению в степень

Если максимальное количество попыток совпадает с размером списка - линейное время

Специальная нотация О-большое описывает скорость работы алгоритма. 

О-большое не сообщает скорость в секундах, а позволяет сравнить количество операций.

О-большое определяет время в худшем случае.
![[Pasted image 20251116080918.png]]

# Глава 2 - Сортировка выбором
Связанные списки отлично подходят, когда данные должны читаться последовательно
Массивы отлично подходят для чтения элементов в произвольных позициях
Позиция элемента называется индексом. 
Вместо "Значение n находится в позиции 1" - "Значение n имеет индекс 1"

Массивы: чтение O(1), вставка О(n), удаление О(n)
Списки: чтение О(n), вставка О(1), удаление О(1)

В каждом элементе связанного списка выделяется некоторый объем памяти для хранения адреса следующего элемента. Эта часть элемента называется указателем

# Глава 3 - Рекурсия
Каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного
В рекурсивном случае функция вызывает сама себя
В базовом случае - не вызывает, чтобы предотвратить зацикливание
Во внутренней работе компьютера используется стек именуемый стеком вызовов

Когда вызывается функция из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии 

Рекурсивные функции используют стек вызовов
Каждый вызов создаёт собственную переменную
Стек поддерживает 2 операции - занесение и извлечение элементов

# Глава 4 - Разделяй и властвуй
1. Определить простейший случай как базовый
2. Придумать, как свести задачу к базовому случаю
Бинарный поиск также относится к этой стратегии, как рекурсия и быстрая сортировка
## Быстрая сортировка
Пример для сортировки массива
Сначала в массиве выбирается элемент, который называется опорным
После чего проводится поиск меньших и больших элементов, чем опорный - этот процесс называется разделением.
Теперь у нас есть: подмассив элементов меньше опорного, опорный элемент, подмассив элементов больших опорного
Вне зависимости от выбора опорного элемента, можно рекурсивно вызывать быструю сортировку для всех подмассивов
![[Pasted image 20251116113759.png]]

Обычно константа не влияет, но в некоторых случая может иметь значение. Один из таких случаев - быстрая сортировка и сортировка слиянием
Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента.
Среднее время выполнения быстрой сортировки О(n log n)

# Глава 5 - Хеш-таблицы
Хеш-таблица связывает ключи со значениями
Хеш-таблицы отлично подходят для: моделирование отношений между объектами, устранение дубликатов, кэширование/запоминание данных вместо выполнения работы на сервере

Коллизия - назначение одного элемента двум ключам
В идеале хеш-функция должна равномерно распределять ключи по всему хешу
В среднем Хеш-таблицы выполняют любые операции за время О(1).
В худшем случае все операции выполняются за О(n)

Для предотвращения коллизий необходимы: низкий коэффициент заполнения, хорошея хеш-функция

Коэффициент заполнения = количество элем в хеш-таблице / общее кол-во элементов

Хорошая хеш-функция должна обеспечивать равномерное распределение значений в массиве

Хеш-таблица создаётся объединением хеш-функции с массивом
Как только коэффициент заполнения превышает 0,7, пора изменять размер хеш-таблицы

# Глава 6 - Поиск в ширину
С помощью поиска в ширину можно: реализовать проверку правописания, найти ближайшего врача, создать поискового робота

Алгоритм для решения задачи поиска кратчайшего пути называется поиском в ширину
Каждый граф состоит из узлов и ребер
Узел может быть соединен с несколькими другими узлами. Эти узлы называются внутренними или внешними соседями

Поиск в ширину может ответить на 2 вопроса:
1. Существует ли путь от узла А к узлу B?
2. Как выглядит кратчайший путь от узла А к узлу B?

В очереди поддерживаются 2 операции: постановка в очередь и извлечение из очереди

Очередь относится к структура данных FIFO - First In, First Out
А Стек к LIFO - Last In, First Out

Направленный граф - отношения действуют только в одну сторону. В ненаправленном графе стрелок нет

Граф, в котором нет ребер, указывающих в обратном направлении - дерево
![[Pasted image 20251116190113.png]]

# Глава 7 - Деревья
Дерево - связный ациклический граф
Как и графы - деревья состоят из узлов и ребер.
Корневое дерево - дерево, у которого имеется 1 узел, от которого можно перейти к любому другому узлу
У узлом могут быть дочерние узлы, а у дочерних узлов может быть родительский узел
Существует только 1 узел без родителя - корневой
Узлы, не имеющие дочерних узлов, называются листовыми узлами(листьями)
Поиск в ширину является алгоритмом обхода: это значит, что он посещает каждый узел дерева
В деревьях не бывает циклов

Поиск в глубину не может использоваться для нахождения кратчайшего пути

Бинарные деревья - деревья, узлы которого могут иметь не более 2 дочерних узлов. Дочерние узлы традиционно называются левым и правым узлами.

Код Хаффмана - хороший пример использования бинарных деревьев. Он также лежит в основе алгоритмов сжатия текста
В кодировке Хаффмана коды не обязательно должны иметь одинаковую длину.

![[Pasted image 20251116201950.png]]

# Глава 8 - Сбалансированные деревья
BST - binary search tree (бинарное дерево поиска)
Значение левого дочернего узла всегда меньше, чем значение узла, а значение правого дочернего узла всегда больше
Если можно обеспечить высоту дерева в O(logn), то поиск по дереву будет выполняться за время O(logn)
Высота дерева для худшего случая равна O(n)!

АВЛ-деревья составляют разновидность самобалансируемых BST. Это означает, что АВЛ-деревья сохраняют высоту O(logn). Каждый раз, когда дерево разбалансируется, то есть его высота становится отлично от О(logn), оно корректирует себя.
Повороты - популярный метод балансировки деревьевм
![[Pasted image 20251117075708.png]]

Чтобы дерево знало, когда требуется самобалансировка, оно должно хранить дополнительную информацию. В каждом узле хранится один или два вида информации: значение высоты или значение, которое иногда называют коэффициентом балансировки. Этот коэффициент должен быть равен -1, 0 или 1
![[Pasted image 20251117081334.png]]
Вставки выполняются за время O(logn)
![[Pasted image 20251117081651.png]]
Косые деревья (или Splay-деревья) представляют другой подход к сбалансированным деревьям BST. Их самое замечательное свойство в том, что если вы недавно искали какой-то элемент, то следующий его поиск будет быстрее.

Когда ищется узел в косом дереве, он становится корневым узлом, так что при повторном поиске он будет найден сразу же.
Дерево заведомо не будет сбалансировано, некоторые операции будут занимать время больше O(logn) и даже достигать линейного времени

Главное, что при проведении n операций поиска общее время O(n log n) гарантировано — то есть O(log n) на один поиск. Таким образом, хотя один поиск может занять время, превышающее O(log n), в среднем все операции поиска сходятся ко времени O(log n)



В-деревья представляют собой обобщенную форму бинарных деревьев. Они часто используются для построения баз данных
![[Pasted image 20251117082222.png]]
В отличие от бинарных деревье, в В-деревьях узлы могут иметь много дочерних узлов. В в-дереве много узлы имеют 2 ключа

Для B-деревьев существует оптимизация, интересная тем, что применяется на физическом уровне. При поиске по дереву получение данных требует перемещения механических компонентов оборудования (например, читающей головки на HDD). Время получения данных называется временем поиска. Оно может быть важным фактором, определяющим, насколько быстро или медленно работает алгоритм.

Фундаментальная концепция В-деревьев заключается в том, что после выполнения поиска можно прочитать дополнительные данные в память

В B-деревьях используются большие узлы; каждый узел может иметь больше ключей и дочерних узлов, чем бинарное дерево. Таким образом, чтение каждого узла занимает больше времени. С другой стороны, поиск ускоряется, потому что за один раз читается больший объем данных. Именно это обстоятельство обеспечивает высокую скорость работы B-деревьев.

![[Pasted image 20251117082630.png]]

![[Pasted image 20251117082722.png]]

# Глава 9 - Алгоритм Дейкстры
Алгоритм Дейкстры используется для поиска пути от начальной точки к конечной за кратчайшее возможное время
![[Pasted image 20251117084519.png]]
![[Pasted image 20251117085038.png]]
Каждое ребро графа имеет число, именуемое весом. Граф с весами называется взвешенным графом. Граф без весов называется невзвешенным графом.
![[Pasted image 20251117085204.png]]
Для вычисления кратчайшего пути в невзвешенном графе используется поиск в ширину. Кратчайшие пути во взвешенном графе измеряются по алгоритму Дейкстры. В графах также могут присутствовать циклы.
![[Pasted image 20251117085353.png]]
Само понятие ненаправленного графа означает, что каждый из двух узлов фактически ведет к другому узлу. А это цикл!

Использование алгоритма Дейкстры с графом, содержащим ребра с отрицательным весом, невозможно. Для этого существует специальный алгоритм - алгоритм Беллмана-Форда.
![[Pasted image 20251117090616.png]]

# Глава 10 - Жадные алгоритмы
Не существует алгоритма, который будет вычислять подмножества с приемлемой скоростью
![[Pasted image 20251117093000.png]]
![[Pasted image 20251117093111.png]]

# Глава 11 - Динамическое программирование
Метод динамического программирования начинает с малых задач, а затем переходит к большой задаче
![[Pasted image 20251117110932.png]]
Динамическое программирование работает только в том случае, если каждая подзадача автономна, то есть не зависит от других подзадач
![[Pasted image 20251117112517.png]]

# Глава 12 - алгоритм k ближайших соседей
![[Pasted image 20251117113523.png]]
Регрессия - среднее арифметическое каких-то результатов у k ближайших соседей
![[Pasted image 20251117114226.png]]
![[Pasted image 20251117114437.png]]
OCR (Optical Character Recognition) - оптическое распознавание текста. Алгоритмы OCR основаны на выделении линий, точек и кривых

Первый шаг OCR, в ходе которого перебираются изображения цифр и происходит извлечение признаков, называется тренировкой.


Спам-фильтры используют другой просто алгоритм, называемый нативным классификатором Байеса

![[Pasted image 20251117114956.png]]
![[Pasted image 20251117115131.png]]

# Глава 13 - Что дальше?








